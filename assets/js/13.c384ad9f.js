(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{189:function(n,e,t){"use strict";t.r(e);var a=t(0),s=Object(a.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[n._m(0),n._v(" "),n._m(1),n._v(" "),n._m(2),t("p",[n._v("居然发现该组件写法整体上类似于 Vue 语法。而本身却没有任何编译。看来问题是出在了导入的 VantComponet 这个方法上。下面我们开始详细介绍一下如何利用 VantComponet 来对老项目进行维护。")]),n._v(" "),n._m(3),n._v(" "),t("p",[n._v("小程序组件写法这里就不再介绍。这里我们给出利用 VantComponent 写 Page 的代码风格。")]),n._v(" "),n._m(4),t("p",[n._v("这里你可能感到疑惑，VantComponet 不是对组件 Component 生效的吗？怎么会对页面 Page 生效呢。事实上，我们是可以使用组件来构造小程序页面的。"),t("br"),n._v("\n在官方文档中，我们可以看到 "),t("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("使用 Component 构造器构造页面"),t("OutboundLink")],1),t("br"),n._v("\n事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 Component 构造器构造，拥有与普通组件一样的定义段与实例方法。代码编写如下:")]),n._v(" "),n._m(5),t("p",[n._v("那么组件的生命周期和页面的生命周期又是怎么对应的呢。经过一番测试，得出结果为： (为了简便。只会列出 重要的的生命周期)")]),n._v(" "),n._m(6),n._m(7),n._v(" "),n._m(8),n._v(" "),n._m(9),n._v(" "),t("p",[n._v("此时，我们对 VantComponent 开始进行解析")]),n._v(" "),n._m(10),t("p",[t("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html#%E5%86%85%E7%BD%AE-behaviors",target:"_blank",rel:"noopener noreferrer"}},[n._v("内置behaviors"),t("OutboundLink")],1),t("br"),n._v(" "),t("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html#%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB",target:"_blank",rel:"noopener noreferrer"}},[n._v("组件样式隔离"),t("OutboundLink")],1)]),n._v(" "),n._m(11),n._v(" "),t("p",[n._v("刚刚我们谈到 basic behaviors，代码如下所示")]),n._v(" "),n._m(12),n._m(13),n._v(" "),t("p",[n._v("小程序 watch 和 computed的 代码解析")]),n._v(" "),n._m(14),n._m(15),n._v(" "),t("p",[n._v("现在剩下的也就是 observeProps 以及 behavior 两个文件了，这两个都是为了计算属性而生成的，这里我们先解释 observeProps 代码")]),n._v(" "),n._m(16),n._m(17),n._v(" "),t("p",[n._v("最终 behavior，也就算 computed 实现机制")]),n._v(" "),n._m(18),n._m(19),n._v(" "),t("ul",[n._m(20),n._v(" "),n._m(21),n._v(" "),t("li",[t("p",[n._v("小程序版本 版本2.6.1 Component  目前已经实现了 observers，可以监听 props data "),t("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("数据监听器"),t("OutboundLink")],1),n._v(",目前 VantComponent没有实现，当然本身而言，Page 不需要对 prop 进行监听，因为进入页面压根不会变，而data变化本身就无需监听，直接调用函数即可，所以对page而言，observers 可有可无。")])]),n._v(" "),n._m(22),n._v(" "),n._m(23),n._v(" "),n._m(24)])])},[function(){var n=this.$createElement,e=this._self._c||n;return e("h1",{attrs:{id:"从-vantcomponent-谈-小程序维护"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从-vantcomponent-谈-小程序维护","aria-hidden":"true"}},[this._v("#")]),this._v(" 从 VantComponent 谈 小程序维护")])},function(){var n=this.$createElement,e=this._self._c||n;return e("p",[this._v("在开发小程序的时候，我们总是期望用以往的技术规范和语法特点来书写当前的小程序，所以才会有各色的小程序框架，例如 mpvue、taro 等这些编译型框架。当然这些框架本身对于新开发的项目是有所帮助。而对于老项目，我们又想要利用 vue 的语法特性进行维护，又该如何呢？"),e("br"),this._v("\n在此我研究了一下youzan的 vant-weapp。而发现该项目中的组件是如此编写的。")])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("import { VantComponent } from '../common/component';\n\nVantComponent({\n  mixins: [],\n  props: {\n    name: String,\n    size: String\n  },\n  // 可以使用 watch 来监控 props 变化\n  // 其实就是把properties中的observer提取出来\n  watch: {\n    name(newVal) {\n       ...\n    },\n    // 可以直接使用字符串 代替函数调用\n    size: 'changeSize'\n  },\n  // 使用计算属性 来 获取数据，可以在 wxml直接使用\n  computed: {\n    bigSize() {\n      return this.data.size + 100\n    }\n  }，\n  data: {\n    size: 0\n  },\n  methods: {\n    onClick() {\n      this.$emit('click');\n    },\n    changeSize(size) {\n       // 使用set\n       this.set(size)\n    }\n  },\n\n  // 对应小程序组件 created 周期\n  beforeCreate() {},\n\n  // 对应小程序组件 attached 周期\n  created() {},\n\n  // 对应小程序组件 ready 周期\n  mounted() {},\n\n  // 对应小程序组件  detached 周期\n  destroyed: {}\n});\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("h2",{attrs:{id:"tldr-不多废话，先说结论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tldr-不多废话，先说结论","aria-hidden":"true"}},[this._v("#")]),this._v(" TLDR (不多废话，先说结论)")])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("import { VantComponent } from '../common/component'; \n\nVantComponent({\n  mixins: [],\n  props: {\n    a: String,\n    b: Number\n  },\n  // 在页面这里 watch 基本上是没有作用了，因为只做了props 变化的watch，page不会出现 props 变化\n  // 后面会详细说明为何\n  watch： {},\n  // 计算属性仍旧可用\n  computed: {\n    d() {\n      return c++\n    }\n  },\n  methods: {\n    onLoad() {}\n  },\n  created() {},\n  // 其他组件生命周期\n})\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Component({\n    // 可以使用组件的 behaviors 机制,虽然 React 觉得 mixins 并不是一个很好的方案\n    // 但是在某种程度该方案的确可以复用相同的逻辑代码\n    behaviors: [myBehavior],\n   \n    // 对应于page的options，与此本身是有类型的，而从options 取得数据均为 string类型\n    // 访问 页面 /pages/index/index?paramA=123&paramB=xyz \n    // 如果声明有属性 paramA 或 paramB ，则它们会被赋值为 123 或 xyz，而不是 string类型\n    properties: {\n        paramA: Number,\n        paramB: String,\n    },\n    methods: {\n        // onLoad 不需要 option\n        // 但是页面级别的生命周期却只能写道 methods中来\n        onLoad() {\n            this.data.paramA // 页面参数 paramA 的值 123\n            this.data.paramB // 页面参数 paramB 的值 ’xyz’\n        }\n    }\n\n})\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// 组件实例被创建 到 组件实例进入页面节点树\ncomponent created -> component attched -> \n// 页面页面加载 到  组件在视图层布局完成\npage onLoad -> component ready -> \n// 页面卸载 到 组件实例被从页面节点树移除\npage OnUnload -> component detached\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("p",[this._v("当然 我们重点不是在 onload 和 onunload 中间的状态，因为中间状态的时候，我们可以在页面中使用页面生命周期来操作更好。"),e("br"),this._v("\n某些时候我们的一些初始化代码不应该放在 onload 里面，我们可以考虑放在 component create 进行操作，甚至可以利用 behaviors 来复用初始化代码。"),e("br"),this._v("\n某种方面来说，如果不需要 Vue 风格，我们在老项目中直接利用 Component 代替 Page 也不失为一个不错的维护方案。毕竟官方标准，不用担心其他一系列后续问题。")])},function(){var n=this.$createElement,e=this._self._c||n;return e("h2",{attrs:{id:"vantcomponent-源码解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vantcomponent-源码解析","aria-hidden":"true"}},[this._v("#")]),this._v(" VantComponent 源码解析")])},function(){var n=this.$createElement,e=this._self._c||n;return e("h3",{attrs:{id:"vantcomponent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vantcomponent","aria-hidden":"true"}},[this._v("#")]),this._v(" VantComponent")])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// 赋值，根据 map 的 key 和 value 来进行操作\nfunction mapKeys(source: object, target: object, map: object) {\n  Object.keys(map).forEach(key => {\n    if (source[key]) {\n      // 目标对象 的 map[key] 对应 源数据对象的 key\n      target[map[key]] = source[key];\n    }\n  });\n}\n\n// ts代码，也就是 泛型\nfunction VantComponent<Data, Props, Watch, Methods, Computed>(\n  vantOptions: VantComponentOptions<\n    Data,\n    Props,\n    Watch,\n    Methods,\n    Computed,\n    CombinedComponentInstance<Data, Props, Watch, Methods, Computed>\n  > = {}\n): void {\n  const options: any = {};\n  // 用function 来拷贝 新的数据，也就是我们可以用的 Vue 风格\n  mapKeys(vantOptions, options, {\n    data: 'data',\n    props: 'properties',\n    mixins: 'behaviors',\n    methods: 'methods',\n    beforeCreate: 'created',\n    created: 'attached',\n    mounted: 'ready',\n    relations: 'relations',\n    destroyed: 'detached',\n    classes: 'externalClasses'\n  });\n\n  // 对组件间关系进行编辑，但是page不需要，可以删除\n  const { relation } = vantOptions;\n  if (relation) {\n    options.relations = Object.assign(options.relations || {}, {\n      [`../${relation.name}/index`]: relation\n    });\n  }\n\n  // 对组件默认添加 externalClasses，但是page不需要，可以删除\n  // add default externalClasses\n  options.externalClasses = options.externalClasses || [];\n  options.externalClasses.push('custom-class');\n\n  // 对组件默认添加 basic，封装了 $emit 和小程序节点查询方法，可以删除\n  // add default behaviors\n  options.behaviors = options.behaviors || [];\n  options.behaviors.push(basic);\n\n  // map field to form-field behavior\n  // 默认添加 内置 behavior  wx://form-field\n  // 它使得这个自定义组件有类似于表单控件的行为。\n  // 可以研究下文给出的 内置behaviors\n  if (vantOptions.field) {\n    options.behaviors.push('wx://form-field');\n  }\n\n  // add default options\n  // 添加组件默认配置，多slot\n  options.options = {\n    multipleSlots: true,// 在组件定义时的选项中启用多slot支持\n    // 如果这个 Component 构造器用于构造页面 ，则默认值为 shared\n    // 组件的apply-shared，可以研究下文给出的 组件样式隔离\n    addGlobalClass: true \n  };\n\n  // 监控 vantOptions\n  observe(vantOptions, options);\n\n  // 把当前重新配置的options 放入Component\n  Component(options);\n}\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("h3",{attrs:{id:"basic-behaviors"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#basic-behaviors","aria-hidden":"true"}},[this._v("#")]),this._v(" basic behaviors")])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("export const basic = Behavior({\n  methods: {\n    // 调用 $emit组件 实际上是使用了 triggerEvent\n    $emit() {\n      this.triggerEvent.apply(this, arguments);\n    },\n\n    // 封装 程序节点查询\n    getRect(selector: string, all: boolean) {\n      return new Promise(resolve => {\n        wx.createSelectorQuery()\n          .in(this)[all ? 'selectAll' : 'select'](selector)\n          .boundingClientRect(rect => {\n            if (all && Array.isArray(rect) && rect.length) {\n              resolve(rect);\n            }\n\n            if (!all && rect) {\n              resolve(rect);\n            }\n          })\n          .exec();\n      });\n    }\n  }\n});\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("h3",{attrs:{id:"observe"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#observe","aria-hidden":"true"}},[this._v("#")]),this._v(" observe")])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("export function observe(vantOptions, options) {\n  // 从传入的 option中得到 watch computed  \n  const { watch, computed } = vantOptions;\n\n  // 添加  behavior\n  options.behaviors.push(behavior);\n\n  /// 如果有 watch 对象\n  if (watch) {\n    const props = options.properties || {};\n    // 例如: \n    // props: {\n    //   a: String\n    // },\n    // watch: {\n    //   a(val) {\n    //     // 每次val变化时候打印\n    //     consol.log(val)\n    //   }\n    } \n    Object.keys(watch).forEach(key => {\n      \n      // watch只会对prop中的数据进行 监视\n      if (key in props) {\n        let prop = props[key];\n        if (prop === null || !('type' in prop)) {\n          prop = { type: prop };\n        }\n        // prop的observer被watch赋值，也就是小程序组件本身的功能。\n        prop.observer = watch[key];\n        // 把当前的key 放入prop\n        props[key] = prop;\n      }\n    });\n    // 经过此方法\n    // props: {\n    //  a: {\n    //    type: String,\n    //    observer: (val) {\n    //      console.log(val)\n    //    }\n    //  }\n    // }\n    options.properties = props;\n  }\n\n  // 对计算属性进行封装\n  if (computed) {\n    options.methods = options.methods || {};\n    options.methods.$options = () => vantOptions;\n\n    if (options.properties) {\n      \n      // 监视props，如果props发生改变，计算属性本身也要变\n      observeProps(options.properties);\n    }\n  }\n}\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("h3",{attrs:{id:"observeprops"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#observeprops","aria-hidden":"true"}},[this._v("#")]),this._v(" observeProps")])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("export function observeProps(props) {\n  if (!props) {\n    return;\n  }\n\n  Object.keys(props).forEach(key => {\n    let prop = props[key];\n    if (prop === null || !('type' in prop)) {\n      prop = { type: prop };\n    }\n\n    // 保存之前的 observer，也就是上一个代码生成的prop\n    let { observer } = prop;\n    prop.observer = function() {\n      if (observer) {\n        if (typeof observer === 'string') {\n          observer = this[observer];\n        }\n\n        // 调用之前保存的 observer\n        observer.apply(this, arguments);\n      }\n\n      // 在发生改变的时候调用一次 set 来重置计算属性\n      this.set();\n    };\n    // 把修改的props 赋值回去\n    props[key] = prop;\n  });\n}\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("h3",{attrs:{id:"behavior"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#behavior","aria-hidden":"true"}},[this._v("#")]),this._v(" behavior")])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("\n// 异步调用 setData\nfunction setAsync(context: Weapp.Component, data: object) {\n  return new Promise(resolve => {\n    context.setData(data, resolve);\n  });\n};\n\nexport const behavior = Behavior({\n  created() {\n    if (!this.$options) {\n      return;\n    }\n\n    // 缓存\n    const cache = {};\n    const { computed } = this.$options();\n    const keys = Object.keys(computed);\n\n    this.calcComputed = () => {\n      // 需要更新的数据\n      const needUpdate = {};\n      keys.forEach(key => {\n        const value = computed[key].call(this);\n        // 缓存数据不等当前计算数值\n        if (cache[key] !== value) {\n          cache[key] = needUpdate[key] = value;\n        }\n      });\n      // 返回需要的更新的 computed\n      return needUpdate;\n    };\n  },\n\n  attached() {\n    // 在 attached 周期 调用一次，算出当前的computed数值\n    this.set();\n  },\n\n  methods: {\n    // set data and set computed data\n    // set可以使用callback 和 then\n    set(data: object, callback: Function) {\n      const stack = [];\n      // set时候放入数据\n      if (data) {\n        stack.push(setAsync(this, data));\n      }\n\n      if (this.calcComputed) {\n        // 有计算属性，同样也放入 stack中，但是每次set都会调用一次，props改变也会调用\n        stack.push(setAsync(this, this.calcComputed()));\n      }\n\n      return Promise.all(stack).then(res => {\n        // 所有 data以及计算属性都完成后调用callback\n        if (callback && typeof callback === 'function') {\n          callback.call(this);\n        }\n        return res;\n      });\n    }\n  }\n});\n")])])])},function(){var n=this.$createElement,e=this._self._c||n;return e("h2",{attrs:{id:"写在后面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写在后面","aria-hidden":"true"}},[this._v("#")]),this._v(" 写在后面")])},function(){var n=this.$createElement,e=this._self._c||n;return e("li",[e("p",[this._v("js 是一门灵活的语言(手动滑稽)")])])},function(){var n=this.$createElement,e=this._self._c||n;return e("li",[e("p",[this._v("本身 小程序 Component 在 小程序 Page 之后，就要比Page 更加成熟好用，有时候新的方案往往藏在文档之中，每次多看几遍文档绝不是没有意义的。")])])},function(){var n=this.$createElement,e=this._self._c||n;return e("li",[e("p",[this._v("该方案也只是对 js 代码上有vue的风格，并没在 template 以及 style 做其他文章。")])])},function(){var n=this.$createElement,e=this._self._c||n;return e("li",[e("p",[this._v("该方案性能一定是有所缺失的，因为computed是每次set都会进行计算，而并非根据set 的 data 来进行操作，在删减之后我认为本身是可以接受。如果本身对于vue的语法特性需求不高，可以直接利用 Component 来编写 Page，选择不同的解决方案实质上是需要权衡各种利弊。如果本身是有其他要求或者新的项目，仍旧推荐使用新技术，如果本身是已有项目并且需要维护的，同时又想拥有 Vue 特性。可以使用该方案，因为代码本身较少，而且本身也可以基于自身需求修改。")])])},function(){var n=this.$createElement,e=this._self._c||n;return e("li",[e("p",[this._v("同时，vant-weapp是一个非常不错的项目，推荐各位可以去查看以及star。")])])}],!1,null,null,null);e.default=s.exports}}]);