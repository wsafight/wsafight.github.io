(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{187:function(t,n,e){"use strict";e.r(n);var a=e(0),s=Object(a.a)({},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),e("p",[t._v("最近在使用 Symbol 来做为唯一值，发现 Symbol 无法进行 new 操作，只能当作函数使用，只要进行了new 就会发生类型错误")]),t._v(" "),t._m(2),e("p",[t._v("在不考虑底层实现的情况下，在代码层面是否能够实现一个函数只可以进行调用而不可以进行 new 操作呢？思考之后如下写出：")]),t._v(" "),t._m(3),e("p",[t._v("如果使用 nodejs,window 可以切换为 global, 代码运行结果不变,因为对于个人而言没有适用场景。于是就没有继续研究下去，可是最近在从新翻阅 es6 时候发现 new.target这个属性。")]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),e("p",[t._v("这样的话 我们的代码就可以这样改为")]),t._v(" "),t._m(7),e("p",[t._v("得到与上述代码一样的答案。")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),e("p",[t._v("但是 java抽象类抽象方法需要重写，这个是没有方案的。于是在测试与使用的过程中，却意外发现了超类可以在构造期间访问派生类的原型，利用起来。")]),t._v(" "),t._m(11),e("p",[t._v("之前运行时调用需要重写的方法报错是这样写的。")]),t._v(" "),t._m(12),e("p",[t._v("然而此时利用 new.target ，我就可以利用 构造期间 对子类进行操作报错。")]),t._v(" "),t._m(13),e("p",[t._v("此时可以把运行方法时候发生的错误提前到构造时期，虽然都是在运行期，但是该错误触发机制要早危害要大。反而对代码是一种保护。")]),t._v(" "),e("p",[t._v("当然了，利用超类可以在构造期间访问派生类的原型作用远远不是那么简单，必然是很强大的，可以结合业务场景谈一谈理解和作用。")]),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),e("Utterances",{attrs:{id:5}})],1)},[function(){var t=this.$createElement,n=this._self._c||t;return n("h1",{attrs:{id:"利用-es6-new-target-来对模拟抽象类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#利用-es6-new-target-来对模拟抽象类","aria-hidden":"true"}},[this._v("#")]),this._v(" 利用 es6 new.target 来对模拟抽象类")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"起源"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#起源","aria-hidden":"true"}},[this._v("#")]),this._v(" 起源")])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("new Symbol()\n\n// error\nUncaught TypeError: Symbol is not a constructor\n    at new Symbol (<anonymous>)\n    at <anonymous>:1:1\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("function disConstructor() {\n  if (this !== window) {\n    throw new TypeError(' disConstructor is not a constructor')\n  }\n  console.log('gogo go')\n}\n\n// 测试结果如下\ndisConstructor() // gogo go\n\nnew disConstructor()\n\n// error\nUncaught TypeError:  disConstructor is not a constructor\n    at new disConstructor (<anonymous>:3:15)\n    at <anonymous>:1:1\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"new-target-属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-target-属性","aria-hidden":"true"}},[this._v("#")]),this._v(" new.target 属性")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"介绍-引用-mdn-文档"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介绍-引用-mdn-文档","aria-hidden":"true"}},[this._v("#")]),this._v(" 介绍(引用 mdn 文档)")])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[this._v("new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。"),n("br"),this._v("\n在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined。")])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("function disConstructor() {\n  // 普通的函数调用中，new.target 的值是undefined。\n  if (new.target) {\n    throw new TypeError(' disConstructor is not a constructor')\n  }\n  console.log('gogo go')\n}\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"深入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深入","aria-hidden":"true"}},[this._v("#")]),this._v(" 深入")])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[this._v("难道 es6 特地添加的功能仅仅只能用于检查一下我们的函数调用方式吗？"),n("br"),this._v("\n在查阅的过程各种发现了大多数都方案都是用 new.target 写出只能被继承的类。类似于实现java的抽象类。")])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class Animal {\n  constructor(name, age) {\n    if (new.target === Animal) {\n      throw new Error('Animal class can`t instantiate');\n    }\n    this.name = name\n    this.age = age\n  }\n  // 其他代码\n  ...\n}\n\nclass Dog extends Animal{\n  constructor(name, age, sex) {\n    super(name, age)\n    this.sex = sex\n  }\n}\n\nnew Animal()\n// error\nUncaught Error: Animal class can`t instantiate\n    at new Animal (<anonymous>:4:13)\n    at <anonymous>:1:1\n\nnew Dog('mimi', 12, '公')\n// Dog {name: \"mimi\", age: 12, sex: \"公\"}\n\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class Animal {\n  constructor(name, age) {\n    console.log(new.target.prototype)\n  }\n  // 其他代码\n  ...\n}\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class Animal {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n  }\n\n  getName () {\n    throw new Error('please overwrite getName method')\n  }\n}\n\nclass Dog extends Animal{\n  constructor(name, age, sex) {\n    super(name, age)\n    this.sex = sex\n  }\n}\n\nconst pite = new Dog('pite', 2, '公')\na.getName()\n// error\nUncaught Error: please overwrite getName method\n    at Dog.getName (<anonymous>:8:11)\n    at <anonymous>:1:3\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class Animal {\n  constructor(name, age) {\n    // 如果 target 不是 基类 且 没有 getName 报错\n    if (new.target !== Animal && !new.target.prototype.hasOwnProperty('getName')) {\n      throw new Error('please overwrite getName method')\n    }\n    this.name = name\n    this.age = age\n  }\n}\n\nclass Dog extends Animal{\n  constructor(name, age, sex) {\n    super(name, age)\n    this.sex = sex\n  }\n}\n\nconst pite = new Dog('pite', 2, '公')\n// error\nUncaught Error: please overwrite getName method\n    at new Animal (<anonymous>:5:13)\n    at new Dog (<anonymous>:14:5)\n    at <anonymous>:1:1\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"其他方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他方案","aria-hidden":"true"}},[this._v("#")]),this._v(" 其他方案")])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[this._v("增加 编辑器插件"),n("br"),this._v("\nproxy"),n("br"),this._v("\n修饰器")])}],!1,null,null,null);n.default=s.exports}}]);