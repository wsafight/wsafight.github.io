(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{186:function(e,n,t){"use strict";t.r(n);var a=t(0),r=Object(a.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[e._m(0),e._v(" "),t("p",[e._v("在开发 web 应用程序时，性能都是必不可少的话题。对于webpack打包的单页面应用程序而言，我们可以采用很多方式来对性能进行优化，比方说 tree-shaking、模块懒加载、利用 extrens 网络cdn 加速这些常规的优化。甚至在vue-cli 项目中我们可以使用 --modern 指令生成新旧两份浏览器代码来对程序进行优化。")]),e._v(" "),t("p",[e._v("而事实上，缓存一定是提升web应用程序有效方法之一，尤其是用户受限于网速的情况下。提升系统的响应能力，降低网络的消耗。当然，内容越接近于用户，则缓存的速度就会越快，缓存的有效性则会越高。")]),e._v(" "),t("p",[e._v("以客户端而言，我们有很多缓存数据与资源的方法，例如 标准的浏览器缓存 以及 目前火热的 Service worker。但是，他们更适合静态内容的缓存。例如 html，js，css以及图片等文件。而缓存系统数据，我采用另外的方案。")]),e._v(" "),t("p",[e._v("那我现在就对我应用到项目中的各种 api 请求缓存方案，从简单到复杂依次介绍一下。")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),t("p",[e._v("第一行代码 使用了 es6以上的 Map，如果对map不是很理解的情况下，你可以参考\n"),t("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/set-map",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECMAScript 6 入门 Set 和 Map"),t("OutboundLink")],1),e._v(" 或者 "),t("a",{attrs:{href:"http://exploringjs.com/es6/ch_maps-sets.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Exploring ES6"),t("OutboundLink")],1),e._v(" 关于 map 和 set的介绍，此处可以理解为一个键值对存储结构。")]),e._v(" "),t("p",[e._v("之后 代码 使用 了 async 函数，可以将异步操作变得更为方便。 你可以参考"),t("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/async",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECMAScript 6 入门 async函数"),t("OutboundLink")],1),e._v("来进行学习或者巩固知识。")]),e._v(" "),t("p",[e._v("代码本身很容易理解，是利用 Map 对象对数据进行缓存，之后调用从 Map 对象来取数据。对于及其简单的业务场景，直接利用此代码即可。")]),e._v(" "),t("p",[e._v("调用方式：")]),e._v(" "),e._m(4),e._m(5),e._v(" "),t("p",[e._v("方案一本身是不足的。因为如果考虑同时两个以上的调用此 api，会因为请求未返回而进行第二次请求api。当然，如果你在系统中添加类似于 vuex、redux这样的单一数据源框架，这样的问题不太会遇到，但是有时候我们想在各个复杂组件分别调用api，而不想对组件进行组件通信数据时候，便会遇到此场景。")]),e._v(" "),e._m(6),t("p",[e._v("该代码避免了方案一的同一时间多次请求的问题。同时也在后端出错的情况下对promise进行了删除，不会出现缓存了错误的promise就一直出错的问题。")]),e._v(" "),t("p",[e._v("调用方式:")]),e._v(" "),e._m(7),e._m(8),e._v(" "),t("p",[e._v("该方案是同时需要 一个以上 的api请求的情况下，对数据同时返回，如果某一个api发生错误的情况下。均不返回正确数据。")]),e._v(" "),e._m(9),t("p",[e._v("该方案是同时获取多个服务器数据的方式。可以同时获得多个数据进行操作，不会因为单个数据出现问题而发生错误。")]),e._v(" "),t("p",[e._v("调用方式")]),e._v(" "),e._m(10),e._m(11),e._v(" "),e._m(12),e._v(" "),e._m(13),t("p",[e._v("然后我们定义该数据缓存。我们采用Map 基本相同的api")]),e._v(" "),e._m(14),t("p",[e._v("此时数据类以及操作类 都已经定义好,我们可以在api层这样定义")]),e._v(" "),e._m(15),t("p",[e._v("该方案使用了 过期时间 和 api 参数不同而进行 缓存的方式。已经可以满足绝大部分的业务场景。")]),e._v(" "),t("p",[e._v("调用方式")]),e._v(" "),e._m(16),e._m(17),e._v(" "),t("p",[e._v("和方案四是的解法一致的，但是是基于修饰器来做。\n代码如下：")]),e._v(" "),e._m(18),t("p",[e._v("此时 我们就会使用 类来对api进行缓存")]),e._v(" "),e._m(19),e._m(20),e._v(" "),e._m(21),t("p",[e._v("该代码意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样")]),e._v(" "),e._m(22),t("p",[e._v("所以没有 办法在函数上用修饰器。具体参考"),t("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/decorator",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECMAScript 6 入门 Decorator"),t("OutboundLink")],1),t("br"),e._v("\n此方式写法简单且对业务层没有太多影响。但是不可以动态修改 缓存时间")]),e._v(" "),t("p",[e._v("调用方式")]),e._v(" "),e._m(23),e._m(24),e._v(" "),e._m(25),e._v(" "),t("Valine")],1)},[function(){var e=this.$createElement,n=this._self._c||e;return n("h1",{attrs:{id:"前端-api-请求缓存方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前端-api-请求缓存方案","aria-hidden":"true"}},[this._v("#")]),this._v(" 前端 api 请求缓存方案")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"方案一-数据缓存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案一-数据缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 方案一 数据缓存")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("简单的 数据 缓存，第一次请求时候获取数据，之后便使用数据，不再请求后端api。"),n("br"),this._v("\n代码如下：")])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("const dataCache = new Map()\n\nasync getWares() {\n    let key = 'wares'\n    // 从data 缓存中获取 数据\n    let data = dataCache.get(key)\n    if (!data) {\n        // 没有数据请求服务器\n        const res = await request.get('/getWares')\n        \n        // 其他操作\n        ...\n        data = ...\n\n        // 设置数据缓存\n        dataCache.set(key, data)\n\n    }\n    return data\n} \n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("getWares().then( ... )\n// 第二次调用 取得先前的data\ngetWares().then( ... )\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"方案二-promise缓存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案二-promise缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 方案二 promise缓存")])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("const promiseCache = new Map()\n\ngetWares() {\n    const key = 'wares'\n    let promise = promiseCache.get(key);\n    // 当前promise缓存中没有 该promise\n    if (!promise) {\n        promise = request.get('/getWares').then(res => {\n            // 对res 进行操作\n            ...\n        }).catch(error => {\n            // 在请求回来后，如果出现问题，把promise从cache中删除 以避免第二次请求继续出错S\n            promiseCache.delete(key)\n            return Promise.reject(error)\n        })\n    }\n    // 返回promise\n    return promise\n}\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("getWares().then( ... )\n// 第二次调用 取得先前的promise\ngetWares().then( ... )\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"方案三-多promise-缓存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案三-多promise-缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 方案三 多promise 缓存")])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("const querys ={\n    wares: 'getWares',\n    skus: 'getSku'\n}\nconst promiseCache = new Map()\n\nasync queryAll(queryApiName) {\n    // 判断传入的数据是否是数组\n    const queryIsArray = Array.isArray(queryApiName)\n    // 统一化处理数据，无论是字符串还是数组均视为数组\n    const apis = queryIsArray ? queryApiName : [queryApiName]\n    \n    // 获取所有的 请求服务\n    const promiseApi = []\n\n    apis.forEach(api => {\n        // 利用promise \n        let promise = promiseCache.get(api)\n\n        if (promise) {\n            // 如果 缓存中有，直接push\n            promise.push(promise)\n        } else {\n             promise = request.get(querys[api]).then(res => {\n                // 对res 进行操作\n                ...\n                }).catch(error => {\n                // 在请求回来后，如果出现问题，把promise从cache中删除\n                promiseCache.delete(api)\n                return Promise.reject(error)\n            })\n            promiseCache.set(api, promise)\n            promiseCache.push(promise)\n        }\n    })\n    return Promise.all(promiseApi).then(res => {\n        // 根据传入的 是字符串还是数组来返回数据，因为本身都是数组操作\n        // 如果传入的是字符串，则需要取出操作\n        return queryIsArray ? res : res[0]\n    })\n}\n\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("queryAll('wares').then( ... )\n// 第二次调用 不会去取 wares，只会去skus\nqueryAll(['wares', 'skus']).then( ... )\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"方案四-添加时间有关的缓存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案四-添加时间有关的缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 方案四 添加时间有关的缓存")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("往往缓存是有危害的，如果我们在知道修改了数据的情况下，直接把 cache 删除即可，此时我们调用方法就可以向服务器进行请求。这样我们规避了前端显示旧的的数据。但是我们可能一段时间没有对数据进行操作，那么此时旧的数据就一直存在，那么我们最好规定个时间来去除数据。"),n("br"),this._v("\n该方案是采用了 类 持久化数据来做数据缓存，同时添加了过期时长数据以及参数化。"),n("br"),this._v("\n代码如下：\n首先定义持久化类,该类可以存储 promise 或者 data")])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class ItemCache() {\n    construct(data, timeout) {\n        this.data = data\n        // 设定超时时间，设定为多少秒\n        this.timeout = timeout\n        // 创建对象时候的时间，大约设定为数据获得的时间\n        this.cacheTime = (new Date()).getTime\n    }\n}\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class ExpriesCache {\n    // 定义静态数据map来作为缓存池\n    static cacheMap =  new Map()\n\n    // 数据是否超时\n    static isOverTime(name) {\n        const data = ExpriesCache.cacheMap.get(name)\n        \n        // 没有数据 一定超时\n        if (!data) return true\n\n        // 获取系统当前时间戳\n        const currentTime = (new Date()).getTime()        \n        \n        // 获取当前时间与存储时间的过去的秒数\n        const overTime = (currentTime - data.cacheTime) / 1000\n        \n        // 如果过去的秒数大于当前的超时时间，也返回null让其去服务端取数据\n        if (Math.abs(overTime) > data.timeout) {\n            // 此代码可以没有，不会出现问题，但是如果有此代码，再次进入该方法就可以减少判断。\n            ExpriesCache.cacheMap.delete(name)\n            return true\n        }\n\n        // 不超时\n        return false\n    }\n\n    // 当前data在 cache 中是否超时\n    static has(name) {\n        return !ExpriesCache.isOverTime(name)\n    }\n\n    // 删除 cache 中的 data\n    static delete(name) {\n        return ExpriesCache.cacheMap.delete(name) \n    }\n\n    // 获取\n    static get(name) {\n        const isDataOverTiem = ExpriesCache.isOverTime(name)\n        //如果 数据超时，返回null，但是没有超时，返回数据，而不是 ItemCache 对象\n        return isDataOverTiem ? null : ExpriesCache.cacheMap.get(name).data\n    }\n\n    // 默认存储20分钟\n    static set(name, data, timeout = 1200) {\n        // 设置 itemCache\n        const itemCache = mew ItemCache(data, timeout)\n        //缓存\n        ExpriesCache.cacheMap.set(name, itemCache)\n    }\n}\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("// 生成key值错误\nconst generateKeyError = new Error(\"Can't generate key from name and argument\")\n\n// 生成key值\nfunction generateKey(name, argument) {\n    // 从arguments 中取得数据然后变为数组\n    const params = Array.from(argument).join(',')\n    \n    try{\n        // 返回 字符串，函数名 + 函数参数\n        return `${name}:${params}`\n    }catch(_) {\n        // 返回生成key错误\n        return generateKeyError\n    }\n}\n\nasync getWare(params1, params2) {\n    // 生成key\n    const key = generateKey('getWare', [params1, params2]) \n    // 获得数据\n    let data = ExpriesCache.get(key)\n    if (!data) {\n        const res = await request('/getWares', {params1, params2})\n        // 使用 10s 缓存，10s之后再次get就会 获取null 而从服务端继续请求\n        ExpriesCache.set(key, res, 10)\n    }\n    return data\n}\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("getWares(1,2).then( ... )\n// 第二次调用 取得先前的promise\ngetWares(1,2).then( ... )\n// 不同的参数，不取先前promise\ngetWares(1,3).then( ... )\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"方案五-基于修饰器的方案四"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案五-基于修饰器的方案四","aria-hidden":"true"}},[this._v("#")]),this._v(" 方案五 基于修饰器的方案四")])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("// 生成key值错误\nconst generateKeyError = new Error(\"Can't generate key from name and argument\")\n\n// 生成key值\nfunction generateKey(name, argument) {\n    // 从arguments 中取得数据然后变为数组\n    const params = Array.from(argument).join(',')\n    try{\n        // 返回 字符串\n        return `${name}:${params}`\n    }catch(_) {\n        return generateKeyError\n    }\n}\n\nfunction decorate(handleDescription, entryArgs) {\n    // 判断 当前 最后数据是否是descriptor，如果是descriptor,直接 使用\n    // 例如 log 这样的修饰器\n    if (isDescriptor(entryArgs[entryArgs.length - 1])) {\n        return handleDescription(...entryArgs, [])\n    } else {\n        // 如果不是\n        // 例如 add(1) plus(20) 这样的修饰器\n        return function() {\n            return handleDescription(...Array.protptype.slice.call(arguments), entryArgs)\n        }\n    }\n}\n\nfunction handleApiCache(target, name, descriptor, ...config) {\n    // 拿到函数体并保存\n    const fn = descriptor.value\n    // 修改函数体\n    descriptor.value = function () { \n        const key =  generateKey(name, arguments)\n        // key无法生成，直接请求 服务端数据\n        if (key === generateKeyError)  {\n            // 利用刚才保存的函数体进行请求\n            return fn.apply(null, arguments)\n        }\n        let promise = ExpriesCache.get(key)\n        if (!promise) {\n            // 设定promise\n            promise = fn.apply(null, arguments).catch(error => {\n                 // 在请求回来后，如果出现问题，把promise从cache中删除\n                ExpriesCache.delete(key)\n                // 返回错误\n                return Promise.reject(error)\n            })\n            // 使用 10s 缓存，10s之后再次get就会 获取null 而从服务端继续请求\n            ExpriesCache.set(key, promise, config[0])\n        }\n        return promise \n    }\n    return descriptor;\n}\n\n// 制定 修饰器\nfunction ApiCache(...args) {\n    return decorate(handleApiCache, args)\n}\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class Api {\n    // 缓存10s\n    @ApiCache(10)\n    // 此时不要使用默认值，因为当前 修饰器 取不到\n    getWare(params1, params2) {\n        return request.get('/getWares')\n    }\n}\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("因为函数存在函数提升，所以没有办法利用函数来做 修饰器"),n("br"),this._v("\n例如:")])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("var counter = 0;\n\nvar add = function () {\n  counter++;\n};\n\n@add\nfunction foo() {\n}\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("@add\nfunction foo() {\n}\n\nvar counter;\nvar add;\n\ncounter = 0;\n\nadd = function () {\n  counter++;\n};\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("getWares(1,2).then( ... )\n// 第二次调用 取得先前的promise\ngetWares(1,2).then( ... )\n// 不同的参数，不取先前promise\ngetWares(1,3).then( ... )\n")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[this._v("#")]),this._v(" 总结")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("api的缓存机制与场景在这里也基本上介绍了，基本上能够完成绝大多数的数据业务缓存，在这里我也想请教教大家，有没有什么更好的解决方案，或者这篇博客中有什么不对的地方，欢迎指正，在这里感谢各位了。"),n("br"),this._v("\n同时这里也有很多没有做完的工作，可能会在后面的博客中继续完善。")])}],!1,null,null,null);n.default=r.exports}}]);